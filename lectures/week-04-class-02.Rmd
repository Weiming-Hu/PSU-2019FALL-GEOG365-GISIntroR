---
title: "Spatial Data Visualization"
author: "Weiming Hu"
date: "September 19, 2019"
output: pdf_document
---

```{r env-preparation, include = F}
library(sf)
library(maps)
library(ggmap)
library(rgdal)
library(raster)
library(ggplot2)
library(ggthemes)
library(magrittr)
library(spDataLarge)

knitr::opts_chunk$set(fig.align = "center")
```

## Topics

Below is a summary of the topics covered in this lecture:

- Raster Data
- File Reading and Writing
- Piping Mechanism
- Spatial Data Visualization
	- Static
	- Animated
	- Interactive

## Raster Data

### Basic Information

```{r, out.width = "400px", echo=F}
knitr::include_graphics("../figures/raster-examples.png")
```

Raster maps usually represent continuous phenomena such as elevation, temperature, population density or spectral data. Of course, we can represent discrete features such as soil or land-cover classes also with the help of a raster data model.

The geographic raster data model usually consists of **a raster header** and **a matrix** (with rows and columns) representing equally spaced cells (often also called pixels).

The raster header defines the coordinate reference system, the extent and the origin. The header defines the extent via the number of columns, the number of rows and the cell size resolution. Hence, starting from the origin, we can easily access and modify each single cell by either using the ID, or the index, of a cell or by explicitly specifying the rows and columns.

This matrix representation avoids storing explicitly the coordinates for the four corner points of each cell corner as would be the case for rectangular vector polygons. In fact it only stores one coordinate, namely the origin. This makes raster processing much more efficient and faster than vector data processing.

**Remeber**: for the `raster` package, although the content in a raster object is organized in a matrix, it counts from the **upper left** of the matrix and fills cells **row-wise**.

```{r}
# Create a raster with distinctive values
rast1 <- raster(nrows = 2, ncols = 3, vals = 1:6)

# Query the coordinates of cells
coords <- coordinates(rast1)

# Plot the raster we just created
plot(rast1)

# Overplot the cell number
text(coords, labels = 1:6)
```

### The `raster` class

Rasters can be created from scratch using the `raster()` function. The above code illustrates how to create a `RasterLayer` object. The resulting raster consists of 36 cells (6 columns and 6 rows specified by nrows and ncols) centered around the Prime Meridian and the Equator (see xmn, xmx, ymn and ymx parameters). The CRS is the default of raster objects: WGS84. This means the unit of the resolution is in degrees which we set to 0.5 (res). Values (vals) are assigned to each cell: 1 to cell 1, 2 to cell 2, and so on.

```{r}
rast2 <- raster(
  nrows = 6, ncols = 6, res = 0.5, 
  xmn = -1.5, xmx = 1.5, ymn = -1.5, ymx = 1.5,
  vals = 1:36)

# Q: What is the origin of the raster we just created?
# Is that what you expected?
#

# To examine a raster
# Q: Can you guess some functions that would work on
# rasters to get their attributes?
# 
# You can find a complete list of functions to use 
# in the documentation section XI. Getting and setting
# Raster* dimensions
# 
# ?'raster-package'
```

But most of the time, we create a `raster` from a file. We are going to read data from the package [`spDataLarge`](https://rdrr.io/github/Nowosad/spDataLarge/man/). The data set *srtm* contains the elevation raster data from SRTM of the Zion National Park area

```{r}
# Get the file path to the input TIF image
input.file <- system.file('raster/srtm.tif', package = 'spDataLarge')

# Create raster from a TIF file
rast.srtm <- raster(input.file)

# Q: Examine the attributes of this input raster.
```

The following code writes a raster to your local file disk.

```{r, eval=FALSE}
# Specify the location of the output file
output.file <- 'srtm.tif'

# The TIF image will be created
writeRaster(ras.srtm, format = 'GTiff',
            filename = output.file)
```

You can then open the TIF image in other GIS software for further analysis and visualization if you prefer. For example, I use [QGIS](https://www.qgis.org/en/site/) to generate the following figure which overlays the TIF image on top of [Open Street Map](https://www.openstreetmap.org/). Later on, we will learn how to generate a similar figure within R.

```{r, out.width = "300px", echo=F}
knitr::include_graphics("../figures/raster-qgis.png")
```

Working with rasters is similar to working with matrices.

```{r, results = F, out.width = "800px", fig.asp = 0.4}
# Access values in a raster by index
rast.srtm[1]
rast.srtm[1, 1]

rast.srtm[466:470]
rast.srtm[2, 1:5]

# Get all values in a raster
values(rast.srtm)

# Modify values in a raster by index
rast.srtm[1, ] <- NA

# Modify values in a raster by bounding box
sp.bbox <- c(-0.5, 0.5, -0.5, 0.5) %>%
  extent() %>% as('SpatialPolygons')
proj4string(sp.bbox) <- crs(rast2)

# Create a new raster with the NA values
rast2.hole <- rasterize(sp.bbox, rast2, update = TRUE)

# We can then try to plot the figures side by side
par(mfrow = c(1, 3), mar = c(4, 2, 1, 4))
plot(rast2, legend = F)
plot(sp.bbox, add = T,
     border = 'red')

plot(rast2, legend = F, yaxt = 'n')
plot(sp.bbox, add = T,
     col = 'white',
     border = NA)

plot(rast2.hole)
```

If you would like to plot the figure to a file, you can use the following code:

```{r, eval = F}
# Initialize a device for plotting
png(filename = 'raster-hole.png', width = 800, height = 480)

###############################
# Your plotting codes go here #
###############################

# Turn off the device to complete the file creation
dev.off()

# Q: Try to make mores plots without turning off the device,
# what would happen?
# 
```

## Visualization

### Rasters

The following code shows how to generate the same overlay map within R.

```{r, message = F, out.width = "300px", fig.align="center"}
# Convert raster to a flat table
df.rast.srtm <- as.data.frame(
  rast.srtm, xy = T)

# Generate plot using the default map
bbox <- bbox(rast.srtm)
map <- get_map(location = bbox)

# Generate plot using Google map
# register_google(key = '<Your API Key>')
# map <- get_map(location = rowMeans(bbox),
#                maptype = 'roadma')

p <- ggmap(map) +
  geom_raster(
    data = df.rast.srtm,
    mapping = aes(
      x = x, y = y, fill = srtm)) +
  scale_fill_viridis_c(alpha = 0.6) +
  coord_equal() +
  theme_map()

# ggsave(p, filename = '../figures/raster-google.png', width = 9)
print(p)
```

If you set up the Google API key, you can create the following figure.

```{r, out.width = "300px", echo=F}
knitr::include_graphics("../figures/raster-google.png")
```

Use `ggmap::register_google()` to check the instructions for setting up the API key.

### Rasters and Vectors

Now that we have learned both rasters and vectors, let's try to visualize them together. We are still going to look at the Zion National Park.

```{r, out.width = "400px", fig.asp = 0.6}
# The dataset containing randomly
# located points in the Zion National Park
# 
zion.sfpts <- st_geometry(zion_points)[1:10]

# Define 1 row and 2 columns
par(mfrow = c(1, 2))

# Plot the base elevation map
plot(rast.srtm)

# Plot the random points with ID
plot(zion.sfpts, add = T, pch = 1, cex = 2)
text(st_coordinates(zion.sfpts),
     label = 1:length(zion.sfpts),
     cex = 0.7)

# Convert sf to sp
zion.pts <- as_Spatial(zion.sfpts)

# Extract values
vals <- extract(rast.srtm, zion.pts)

# Barplot
barplot(names.arg = 1:length(zion.pts), height = vals)
```

If we have extra time, please try to reflect on and complete the following questions:

- Do you prefer the ink-on-paper style or the grammar of graphic style?
- Can you reproduce the above figures using `ggplot2`?
- Can you select an area on the map and plot it?
- Choose a different set of points and visualize their elevation. Try to make the elevation from high to low. *Hint: Use click() to get the coordinates from a raster.*